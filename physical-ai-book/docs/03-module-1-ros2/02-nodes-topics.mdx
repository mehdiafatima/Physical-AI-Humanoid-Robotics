---
title: "Chapter 2: ROS 2 Nodes and Topics"
description: "A deep dive into ROS 2 nodes and topics, the fundamental communication mechanisms, with practical Python examples and best practices."
---

import { FaProjectDiagram, FaExchangeAlt, FaCogs } from 'react-icons/fa';

Building upon the foundational concepts of ROS 2, this chapter delves into two of its most crucial communication primitives: **Nodes** and **Topics**. These mechanisms form the backbone of how distributed components of a robot application interact and exchange data asynchronously.

## 2.1. ROS 2 Nodes: The Executables

In ROS 2, a **Node** is an executable program that performs a specific, focused task within the robotics system. Each node is designed to be modular and reusable, promoting a clear separation of concerns.

<div className="card" style={{margin: '2rem 0'}}>
  <div className="card__header" style={{backgroundColor: 'var(--ifm-color-primary-dark)', color: 'white'}}>
    <h3><FaCogs /> Why Use Nodes?</h3>
  </div>
  <div className="card__body">
    <ul>
      <li>**Modularity**: Break down complex robotic systems into smaller, manageable, and testable units.</li>
      <li>**Fault Isolation**: If one node crashes, the rest of the system can often continue to operate without interruption.</li>
      <li>**Reusability**: Well-designed nodes can be reused across different robot platforms or projects.</li>
      <li>**Distribution**: Nodes can run on different machines or even different processes on the same machine, enabling distributed computation.</li>
    </ul>
  </div>
</div>

### Creating a Simple ROS 2 Node (Python)

Let's create a minimal "talker" node that periodically publishes a "Hello World" message.

#### 1. Create a New ROS 2 Package:
```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python my_ros2_package
```
This creates a `my_ros2_package` directory with the basic structure for a Python package.

#### 2. Add Python Code for the Talker Node:

Create `my_ros2_package/my_ros2_package/talker_node.py`:
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String # Standard string message type

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2 World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 3. Register the Executable:
Edit `my_ros2_package/setup.py` and add the entry point:
```python
# ... other imports
entry_points={
    'console_scripts': [
        'talker = my_ros2_package.talker_node:main',
    ],
},
# ... rest of setup.py
```

#### 4. Build and Run:
```bash
cd ~/ros2_ws
colcon build --packages-select my_ros2_package
source install/setup.bash
ros2 run my_ros2_package talker
```

## 2.2. ROS 2 Topics: Asynchronous Data Flow <FaExchangeAlt />

**Topics** are named buses over which nodes send (publish) and receive (subscribe) messages. They are the most common way for nodes to exchange data in a decoupled, asynchronous manner.

### Key Characteristics of Topics:
-   **Decoupled**: Publishers and subscribers do not need to know about each other's existence.
-   **Asynchronous**: Messages are sent and received as they become available, without blocking.
-   **One-to-Many Communication**: One publisher can send messages to multiple subscribers, and one subscriber can receive messages from multiple publishers.
-   **Strongly Typed**: Each topic has a specific message type, ensuring data consistency.

### Creating a Simple ROS 2 Subscriber (Python)

Let's create a "listener" node that subscribes to the `topic` published by our talker node.

#### 1. Add Python Code for the Listener Node:
Create `my_ros2_package/my_ros2_package/listener_node.py`:
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 2. Register the Executable:
Edit `my_ros2_package/setup.py` to add the listener's entry point:
```python
# ...
entry_points={
    'console_scripts': [
        'talker = my_ros2_package.talker_node:main',
        'listener = my_ros2_package.listener_node:main',
    ],
},
# ...
```

#### 3. Build and Run:
```bash
# In Terminal 1:
ros2 run my_ros2_package talker
# In Terminal 2:
ros2 run my_ros2_package listener
```
You should see the listener printing messages from the talker.

## 2.3. Quality of Service (QoS) Settings

ROS 2's DDS layer allows for sophisticated **Quality of Service (QoS)** settings to control communication behavior.

:::info QoS Profiles
QoS profiles define parameters such as:
-   **Reliability**: `RELIABLE` (guaranteed delivery) vs. `BEST_EFFORT` (for high-frequency, non-critical data).
-   **Durability**: `TRANSIENT_LOCAL` (new subscribers receive previously published messages) vs. `VOLATILE`.
-   **History**: `KEEP_LAST` (store a limited number of messages) vs. `KEEP_ALL`.
-   **Depth**: The number of messages to store when using `KEEP_LAST`.
:::

### Example QoS Profile (Python):
```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)
self.publisher_ = self.create_publisher(String, 'topic', qos_profile)
```

## Conclusion

Nodes and Topics are the bedrock of ROS 2 communication, enabling a flexible, distributed, and scalable architecture. A solid understanding of these concepts, combined with appropriate use of QoS settings, is essential for building robust and efficient robotic systems. The next chapter will explore synchronous communication patterns with Services and Actions.
