---
title: "Chapter 3: Services, Actions, and Parameters"
description: "Exploring ROS 2 services, actions, and parameters for advanced robot control, configuration, and long-running tasks, with practical examples."
---

import { FaSyncAlt, FaTasks, FaSlidersH } from 'react-icons/fa';



Beyond the asynchronous data flow of topics, ROS 2 provides richer interaction patterns essential for building responsive and configurable robotic systems. This chapter delves into **Services**, **Actions**, and **Parameters**â€”mechanisms that enable synchronous communication, long-running goal management, and dynamic configuration.

## 3.1. ROS 2 Services: Synchronous Request/Reply <FaSyncAlt />

**Services** are designed for synchronous, request-reply communication. A client node sends a request to a service server, which processes it and returns a single response. This pattern is ideal for operations that have a clear start and end, and where the client needs an immediate, confirmed result.

:::info When to Use Services
-   Triggering an emergency stop.
-   Requesting the current pose of a robot.
-   Setting a specific joint angle or robot configuration.
-   Querying the status of a hardware component.
:::

### Service Definition (`.srv` file)

Services require a `.srv` file to define the structure of the request and response. Create `my_ros2_package/srv/AddTwoInts.srv`:
```text
int64 a
int64 b
---
int64 sum
```
The `---` separates the request fields (top) from the response fields (bottom).

### Implementing a Service Server (Python)

Let's create a server node that provides an `AddTwoInts` service.

#### 1. Add Server Code:
Create `my_ros2_package/my_ros2_package/add_two_ints_server.py`:
```python
import rclpy
from rclpy.node import Node
from my_ros2_package.srv import AddTwoInts

class AddTwoIntsService(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Add two ints service is ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')
        self.get_logger().info(f'Sending response: sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    service = AddTwoIntsService()
    rclpy.spin(service)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 2. Implement a Service Client (Python)
Create `my_ros2_package/my_ros2_package/add_two_ints_client.py`:
```python
import sys
import rclpy
from rclpy.node import Node
from my_ros2_package.srv import AddTwoInts

class AddTwoIntsClient(Node):
    def __init__(self):
        super().__init__('add_two_ints_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    
    if len(sys.argv) != 3:
        print('Usage: ros2 run my_ros2_package add_two_ints_client A B')
        sys.exit(1)
    
    client = AddTwoIntsClient()
    response = client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    
    if response:
        client.get_logger().info(
            f'Result of add_two_ints: {sys.argv[1]} + {sys.argv[2]} = {response.sum}')
    else:
        client.get_logger().error('Service call failed')
    
    client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 3. Build and Run:
After updating your `package.xml`, `CMakeLists.txt`, and `setup.py` to include the service definition and executables:
```bash
# In Terminal 1:
ros2 run my_ros2_package add_two_ints_server
# In Terminal 2:
ros2 run my_ros2_package add_two_ints_client 5 7
```

## 3.2. ROS 2 Actions: Long-Running Goals <FaTasks />

**Actions** are designed for long-running, preemptable tasks where continuous feedback is required. Unlike services, actions allow the client to monitor progress and cancel the goal mid-execution.

### Action Definition (`.action` file)
An action is defined in a `.action` file, which specifies the goal, the result, and the feedback. Create `my_ros2_package/action/Fibonacci.action`:
```text
# Goal
int32 order
---
# Result
int32[] sequence
---
# Feedback
int32[] partial_sequence
```

Implementing action servers and clients is more involved, typically requiring dedicated callback functions for goal handling, feedback publishing, and result sending, all managed through the `rclpy.action` module.

## 3.3. ROS 2 Parameters: Dynamic Configuration <FaSlidersH />

**Parameters** provide a flexible way to configure nodes dynamically at runtime, without needing to restart them. This is invaluable for tuning algorithm constants, changing operational modes, or adjusting sensor settings.

### Declaring and Using Parameters (Python)
Nodes can declare parameters with default values and register callbacks for when they are changed.

```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import SetParametersResult

class MinimalParam(Node):
    def __init__(self):
        super().__init__('minimal_param_node')
        self.declare_parameter('my_parameter', 'world')
        self.timer = self.create_timer(1, self.timer_callback)
        self.add_on_set_parameters_callback(self.parameter_callback)

    def timer_callback(self):
        my_param = self.get_parameter('my_parameter').get_parameter_value().string_value
        self.get_logger().info(f'Hello {my_param}!')

    def parameter_callback(self, params):
        for param in params:
            if param.name == 'my_parameter' and param.type_ == param.Type.STRING:
                self.get_logger().info(f'Parameter "my_parameter" changed to: {param.value}')
        return SetParametersResult(successful=True)

def main(args=None):
    rclpy.init(args=args)
    node = MinimalParam()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Running and Modifying Parameters:
```bash
# In Terminal 1 (run the node):
ros2 run my_ros2_package minimal_param

# In Terminal 2 (get parameter):
ros2 param get /minimal_param_node my_parameter

# In Terminal 2 (set parameter):
ros2 param set /minimal_param_node my_parameter "ROS 2"
```

## Conclusion

Services, Actions, and Parameters extend ROS 2's communication capabilities beyond simple messaging. By enabling synchronous interactions, managing long-running tasks, and allowing dynamic reconfiguration, they provide the essential tools for building interactive, responsive, and sophisticated robotic systems.
