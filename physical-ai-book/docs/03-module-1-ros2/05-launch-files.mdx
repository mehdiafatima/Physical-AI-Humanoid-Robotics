---
title: "Chapter 5: Launch Files and Package Management"
description: "Mastering ROS 2 application management with launch files and understanding package structures for efficient, reproducible, and scalable robotics projects."
---

import { FaRocket, FaBoxOpen, FaCogs } from 'react-icons/fa';


As ROS 2 applications grow in complexity, managing multiple nodes, their parameters, and configurations becomes a significant challenge. This chapter introduces **Launch Files**, a powerful mechanism for orchestrating ROS 2 components, and delves into best practices for **Package Management** to ensure your robotics projects are maintainable, reproducible, and scalable.

## 5.1. ROS 2 Launch Files: Orchestrating Your System

**Launch files** are Python scripts that allow you to define, configure, and run a system of multiple ROS 2 nodes simultaneously. They are the standard way to bring up a complete robot system with a single command, streamlining the entire deployment process.

<div className="card" style={{margin: '2rem 0'}}>
  <div className="card__header" style={{backgroundColor: 'var(--ifm-color-primary-dark)', color: 'white'}}>
    <h3><FaCogs /> Key Features of Launch Files</h3>
  </div>
  <div className="card__body">
    <ul>
      <li>**Node Orchestration**: Start multiple nodes at once, including servers, clients, drivers, and visualization tools.</li>
      <li>**Parameter Assignment**: Set parameters for your nodes at launch time, allowing for easy configuration changes.</li>
      <li>**Remapping**: Change node, topic, or service names to avoid conflicts or to integrate components from different packages.</li>
      <li>**Conditional Execution**: Use `If` and `Unless` statements to dynamically run nodes based on launch arguments or conditions.</li>
      <li>**Modularity and Reusability**: Include and reuse launch files from other packages, promoting a clean, modular architecture.</li>
    </ul>
  </div>
</div>

### Example: A Simple Python Launch File

Let's create a launch file that starts our `talker` and `listener` nodes from the previous chapter.

#### 1. Create a Launch Directory:
```bash
mkdir -p my_ros2_package/launch
```

#### 2. Create the Launch File:
Create `my_ros2_package/launch/my_simple_launch.py`:
```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_ros2_package',
            executable='talker',
            name='my_talker',
            output='screen',
            emulate_tty=True
        ),
        Node(
            package='my_ros2_package',
            executable='listener',
            name='my_listener',
            output='screen',
            emulate_tty=True
        )
    ])
```

#### 3. Update `setup.py`:
You must inform `colcon` where to find your launch files. Add the launch directory to `data_files` in `my_ros2_package/setup.py`:
```python
# ... other imports
import os
from glob import glob

data_files=[
    ('share/ament_index/resource_index/packages', ['resource/' + package_name]),
    ('share/' + package_name, ['package.xml']),
    (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*launch.[pxy]'))),
],
# ... rest of setup.py
```

#### 4. Build and Run:
```bash
cd ~/ros2_ws
colcon build --packages-select my_ros2_package
source install/setup.bash
ros2 launch my_ros2_package my_simple_launch.py
```
This single command will start both the talker and listener nodes, demonstrating the power of orchestration.

## 5.2. ROS 2 Package Management: Structure and Dependencies <FaBoxOpen />

A **ROS 2 Package** is the primary unit for organizing your ROS 2 code. Each package is a self-contained directory that can include nodes, libraries, custom message definitions, configuration files, and launch files. Proper package management is crucial for modularity, reusability, and collaborative development.

### Recommended Package Structure:

A well-structured package is easy to navigate and maintain.
```text
my_ros2_package/
├── CMakeLists.txt        # Build instructions for C++ packages
├── package.xml           # Package metadata and dependencies (CRITICAL)
├── setup.py              # Python package setup and entry points
├── launch/               # Launch files (.launch.py)
├── config/               # Configuration files (.yaml)
├── srv/                  # Service definitions (.srv)
├── action/               # Action definitions (.action)
├── include/              # C++ header files (.hpp)
│   └── my_ros2_package/
├── src/                  # C++ source files (.cpp)
├── my_ros2_package/      # Python module directory
│   ├── __init__.py
│   ├── talker_node.py
│   └── listener_node.py
└── test/                 # Unit and integration tests
```

### Declaring Dependencies in `package.xml`:
Dependencies on other ROS 2 packages or system libraries are declared in `package.xml`. This file is essential for `rosdep` to automatically install system dependencies and for `colcon` to build your packages in the correct order.

:::caution Attention
Incorrect or missing dependencies in `package.xml` is a common source of build failures.
:::

```xml
<depend>rclpy</depend>
<depend>std_msgs</depend>
<exec_depend>ros2launch</exec_depend>
```

### The Build Tool: `colcon`
`colcon` (collective construction) is the standard build tool for ROS 2. It discovers packages, respects their inter-dependencies, and orchestrates the build process.

-   `colcon build`: Builds all packages in the workspace.
-   `colcon build --packages-select my_ros2_package`: Builds only a specific package.
-   `colcon test`: Runs all tests in the workspace.

## Conclusion

Launch files and robust package management are indispensable for developing professional-grade robotics applications. They transform a collection of individual nodes into a cohesive, manageable, and deployable system. Mastering these tools culminates our deep dive into ROS 2 fundamentals and prepares you for the complex, multi-component systems explored in the upcoming modules.
